#!/bin/sh
# alint APKBUILD - scan APKBUILD template for common mistakes
#
# Adapted from xlint from Void Linux's xtools to Alpine Linux
# https://github.com/leahneukirchen/xtools/
#
# Required packages (names are Alpine Linux pkgs):
# busybox - for sed, tr, sort and other simple utiltiies
# grep - for grep with -P

export LC_ALL=C

# Finds from which repo a package comes from
# it can return multiple values if it finds multiple matches
find_repo() {
	[ -z "$1" ] || [ -z "$2" ] && return 0

	local pkgname="$1"
	# Repo the package we are linting currently is. We want it
	# for avoiding checks on repos we don't want
	local targetrepo="$2"

	# Unmaintained is the top of the ladder, it can depend on any
	# of the steps below
	if [ "$targetrepo" = "unmaintained" ]; then
		return 0
	fi

	# Perform some transformations that can be done easily and cheaply
	# and are common.
	#
	# This is a hack until apk has something like xpkg -m or aports adopt
	# the xbps-src symlinks
	pkgname="${pkgname%-dev}"
	pkgname="${pkgname%-doc}"
	pkgname="${pkgname%-openrc}"
	pkgname="${pkgname%-bash-completion}"
	pkgname="${pkgname%-zsh-completion}"
	pkgname="${pkgname%-fish-completion}"
	# Disabled because it can cause conflicts with -dev packages, there is glade and libglade
	# which are separate packages but end up causing false-postiives
	# pkgname="${pkgname#lib}"
	pkgname="${pkgname%-static}"
	pkgname="${pkgname%-lang}"

	check_in_repo() { test -d "$1"/"$2" && echo "$1" ; }

	case "$targetrepo" in
		testing) 
			check_in_repo unmaintained "$pkgname"
			;;
		community)
			check_in_repo unmaintained "$pkgname"
			check_in_repo testing "$pkgname"
			;;
		main)
			check_in_repo unmaintained "$pkgname"
			check_in_repo testing "$pkgname"
			check_in_repo community "$pkgname"
			;;
	esac
}

find_dupe() {
	local pkgname="$1" repo="$2" r=

	check_in_repo() { test -d "$1"/"$2" && echo "$1" ; }

	for r in unmaintained testing community main; do
		[ "$r" = "$repo" ] && continue
		check_in_repo "$r" "$pkgname"
	done
}

scan() {
	local rx="$1" msg="$2"
	grep -P -Hn -e "$rx" "$apkbuild" |
		sed "s/^\([^:]*:[^:]*:\)\(.*\)/\1 $msg/"
}

variables=$(echo -n "#.*
_.*
startdir
srcdir
pkgdir
subpkgdir
builddir
arch
depends
depends_dev
checkdepends
giturl
install
.*.pre-install
.*.post-install
.*.pre-upgrade
.*.post-upgrade
.*.pre-deinstall
.*.post-deinstall
install_if
license
makedepends
md5sums
sha256sums
sha512sums
options
pkgdesc
pkggroups
pkgname
pkgrel
pkgusers
pkgver
provides
provider_priority
replaces
replaces_priority
source
subpackages
triggers
ldpath
url" | tr '\n' '|')

default_builddir_value() {
	[ "$SKIP_DEFAULT_BUILDDIR_VALUE" ] && return 0
	if [ "$builddir" = "/$pkgname-$pkgver" ]; then
		scan '^builddir=' "builddir can be removed as it is the default value"
	fi
}

upper_repo_depends() {
	[ "$SKIP_UPPER_REPO_DEPENDS" ] && return 0
	printf "%s\n" "$depends" | tr " " "\n" | sort -u | while read -r pkg; do
		for p in $(find_repo "$pkg" "$_repo"); do
			printf "$apkbuild:: depends '$pkg' is in upper repo '$p'\n"
		done
	done
}

duplicate_depends() {
	[ "$SKIP_DUPLICATE_DEPENDS" ] && return 0
	printf "%s\n" "$depends" | tr " " "\n" | sort | uniq -d | while read -r dup; do
		[ -z "$dup" ] && continue
		printf "$apkbuild:: duplicate '$dup' in depends\n"
	done
}

upper_repo_makedepends() {
	[ "$SKIP_UPPER_REPO_MAKEDEPENDS" ] && return 0
	printf "%s\n" "$makedepends" | tr " " "\n" | sort -u | while read -r pkg; do
		for p in $(find_repo "$pkg" "$_repo"); do
			printf "$apkbuild:: makedepends '$pkg' is in upper repo '$p'\n"
		done
	done
}

duplicate_makedepends() {
	[ "$SKIP_DUPLICATE_MAKEDEPENDS" ] && return 0
	printf "%s\n" "$makedepends" | tr " " "\n" | sort | uniq -d | while read -r dup; do
		[ -z "$dup" ] && continue
		printf "$apkbuild:: duplicate '$dup' in makedepends\n"
	done
}

upper_repo_checkdepends() {
	[ "$SKIP_UPPER_REPO_CHECKDEPENDS" ] && return 0
	printf "%s\n" "$checkdepends" | tr " " "\n" | sort -u | while read -r pkg; do
		for p in $(find_repo "$pkg" "$_repo"); do
			printf "$apkbuild:: checkdepends '$pkg' is in upper repo '$p'\n"
		done
	done
}

duplicate_checkdepends() {
	[ "$SKIP_DUPLICATE_CHECKDEPENDS" ] && return 0
	printf "%s\n" "$checkdepends" | tr " " "\n" | sort | uniq -d | while read -r dup; do
		[ -z "$dup" ] && continue
		printf "$apkbuild:: duplicate '$dup' in checkdepends\n"
	done
}

unnecessary_return_1() {
	[ "$SKIP_UNNECESSARY_RETURN_1" ] && return 0
	scan '\|\| return 1' "|| return 1 is not required as set -e is used"
}

pkgname_quoted() {
	[ "$SKIP_PKGNAME_QUOTED" ] && return 0
	scan '^pkgname="[^$]+"' "pkgname must not be quoted"
}

pkgver_quoted() {
	[ "$SKIP_PKGVER_QUOTED" ] && return 0
	scan '^pkgver="[^$]+"' "pkgver must not be quoted"
}

empty_variable() {
	[ "$SKIP_EMPTY_VARIABLE" ] && return 0
	scan '^[ =]*=(|""|''|)$' "variable set to empty string: \2"
}

custom_variable() {
	[ "$SKIP_CUSTOM_VARIABLE" ] && return 0
	scan '^(?!\s*^('"$variables"'))[^\s=-]+=' \
		"prefix custom variable with _: \2"
}

indent_tabs() {
	[ "$SKIP_INDENT_TABS" ] && return 0
	scan '^  ' "indent with tabs"
}

trailing_whitespace() {
	[ "$SKIP_TRAILING_WHITESPACE" ] && return 0
	scan '[\t ]$' "trailing whitespace"
}

backticks_usage() {
	[ "$SKIP_BACKTICKS_USAGE" ] && return 0
	scan '[^\\]`' "use \$() instead of backticks"
}

function_keyword() {
	[ "$SKIP_FUNCTION_KEYWORD" ] && return 0
	scan '^\t*function\b' 'do not use the function keyword'
}

space_before_function_parenthesis() {
	[ "$SKIP_SPACE_BEFORE_FUNCTION_PARENTHESIS" ] && return 0
	scan '^\t*[^ ]*  *\(\)' 'do not use space before function parenthesis'
}

space_after_function_parenthesis() {
	[ "$SKIP_SPACE_AFTER_FUNCTION_PARENTHESIS" ] && return 0
	scan '^\t*[^ ]*\(\)(|   *){' 'use one space after function parenthesis'
}

newline_opening_brace() {
	[ "$SKIP_NEWLINE_OPENING_BRACE" ] && return 0
	scan '^\t*[^ ]*\(\)$' 'do not use a newline before function opening brace'
}

duplicate_package() {
	for _r in $(find_dupe "$pkgname" "$_repo"); do
		printf "$apkbuild:: package is already present in $_r\n"
	done
}

superfluous_cd_builddir() {
	[ "$SKIP_SUPERFLUOUS_CD_BUILDDIR" ] && return 0
	sed -n "/^$1() {/,/^}/{p;=}" "$apkbuild" | grep -m 1 -B 1 'cd "$builddir"$' | head -1 | while read -r l; do
		[ -z "$l" ] && continue
		printf "$apkbuild:$l: cd \"\$builddir\" can be removed in phase '$1'\n"
	done
}

ret=0
for apkbuild; do
	if [ -f "$apkbuild" ]; then

	# Try to guess the repo, first see if our working directory is where
	# the repo is located
	_repo="${PWD%/*}"
	_repo="${repo%/*}"
	_repo="${repo##*/}"
	case "$repo" in
		main|community|testing|unmaintained) ;;
		# Then have the path given to use be used
		*)
			_repo="${apkbuild%/*}"
			_repo="${repo%/*}"
			_repo="${repo##*/}"
			;;
	esac

	# Source apkbuild, we need some nice values
	srcdir="" . "$apkbuild" 2>/dev/null
	default_builddir_value &

	if [ ! -z "$depends" ]; then
		upper_repo_depends &
		duplicate_depends &
	fi

	if [ ! -z "$makedepends" ]; then
		upper_repo_makedepends &
		duplicate_makedepends &
	fi

	if [ ! -z "$checkdepends" ]; then
		if [ ! -z "${options##*!check*}" ]; then
			upper_repo_checkdepends &
		fi
		duplicate_checkdepends &
	fi

	unnecessary_return_1 &
	pkgname_quoted &
	pkgver_quoted &
	empty_variable &
	custom_variable &
	indent_tabs &
	trailing_whitespace &
	backticks_usage &
	function_keyword &
	space_before_function_parenthesis &
	space_after_function_parenthesis &
	newline_opening_brace &

	if [ -z "$SKIP_DUPLICATE_PACKAGE" ]; then
		duplicate_package &
	fi

	# Don't perform these checks on packages from main
	if ! [ -z "${apkbuild##*main/*}" ]; then
	for phase in prepare build check package; do
		superfluous_cd_builddir "$phase" &
	done
	fi
	wait
	else
	echo no such apkbuild "$apkbuild" 1>&2
	fi | sort -t: -n -k2 | grep . && ret=1
done
exit $ret
